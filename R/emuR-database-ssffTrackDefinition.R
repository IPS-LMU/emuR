
##' Functions used for setting up, listing and deleting definitions related to data track files for an emuDB.
##' 
##
##' An ssffTrack (often simply referred to as a track) references 
##' data that is stored in the Simple Signal File Format (SSFF) 
##' in the corresponding bundle folders. The two most common types of data are:
##' \itemize{
##' \item{derived data, i.e. data that was calculated from the original audio signal 
##' such as formant values and their bandwidths or the short-term Root Mean Square amplitude of the signal.}
##' \item{complementary registrations that was acquired at the same time as the audio recording,
##' such as electromagnetic articulographic (EMA) or electropalatography (EPG) recordings;}
##' }
##' For more information on the structural elements of an emuDB see \code{vignette(emuDB)}.
##' 
##' @param emuDBhandle An \code{emuDB} handle as returned by \code{\link{load_emuDB}}
##' @param name The name by which the track will be refered to in the EmuDB system.
##' @param columnName The column in the output of SSFF track data file, or the output of
##' \code{onTheFlyFunctionName}, that should be associated with the \code{ssffTrackDefinition}
##' being created. If the \code{onTheFlyFunctionName} parameter is set and \code{columnName}
##' is \code{NULL}, the first entry in \code{wrasspOutputInfos[[onTheFlyFunctionName]]$tracks}
##' will be used as \code{columnName}.
##' @param fileExtension The file extension used for the SSFF file in which the track is stored.
##' If the \code{onTheFlyFunctionName} parameter is set and fileExtension is not, the first
##' entry in \code{wrasspOutputInfos[[onTheFlyFunctionName]]$ext} will be used as 
##' \code{fileExtension}.
##' @param onTheFlyFunctionName The name of a \code{wrassp} function which will be applied to
##' audio file for computing values for the ssffTrack on the fly. Trackdata generated by
##' \code{wrassp} signal processing functions will also be stored in the EmuDB. 
##' See \code{names(wrasspOutputInfos)} for a list of all the signal processing functions
##' provided by the \code{\link{wrassp}} package.
##' @param onTheFlyParams A list of parameters that will be given to the function 
##' passed in by the \code{onTheFlyFunctionName} parameter. See the documentation for the 
##' used. For advanced users, a template for this list may be generated using the 
##' \code{\link[base]{formals}} function. This template list may then be adjusted to fit the
##' analisys desired by the user. Please see "examples" below.
##' @param onTheFlyOptLogFilePath path to optional log file for on-the-fly function
##' @param deleteFiles delete files that belong to ssffTrackDefinition on removal
##' @param verbose Show progress bars and further information
##' @param interactive ask user for confirmation
##' @name ssffTrackDefinition
##' @examples 
##' \dontrun{
##' 
##' ##################################
##' # Create the demo databases and load 'ae' 
##' create_emuRdemoData()
##' ae <- load_emuDB(file.path(tempdir(),"emuR_demoData","ae_emuDB"))
##' 
##' # add ssff track definition to ae emuDB
##' # calculating the according SSFF files (.zcr) on-the-fly
##' # using the wrassp function "zcrana" (zero-crossing-rate analysis)
##' add_ssffTrackDefinition(emuDBhandle = ae,
##'                         name = "ZCRtrack",
##'                         onTheFlyFunctionName = "zcrana")
##'                         
##' # add ssff track definition to ae emuDB
##' # for SSFF files that will be added later (either
##' # by adding files to the emuDB using 
##' # the add_files() function or by calculating
##' # them using the according function provided 
##' # by the wrassp package)
##' add_ssffTrackDefinition(emuDBhandle = ae,
##'                         name = "formants",
##'                         columnName = "fm",
##'                         fileExtension = "fms")
##' 
##' # list ssff track definitions for ae emuDB
##' list_ssffTrackDefinitions(emuDBhandle = ae)
##' 
##' # remove newly added ssff track definition (does not delete 
##' # the actual .zrc files)
##' remove_ssffTrackDefinition(emuDBhandle = ae, 
##'                                        name = "ZCRtrack")
##' # Compute a f0 track using the wrassp::ksvF0 function and
##' # with some explicit parameters generated using 'formals()'
##' allParams <- formals("ksvF0")
##' allParams
##' allParams["gender"] <- "f"
##' allParams["minF"] <- 100
##' 
##' add_ssffTrackDefinition(ae,name = "f0", onTheFlyFunctionName = "ksvF0",columnName = "F0",onTheFlyParams = allParams)
##' 
##' # Remove the newly added track and delete created files.
##' remove_ssffTrackDefinition(ae,"f0",deleteFiles = TRUE)
##'  
##' }
##' 
NULL

##' @rdname ssffTrackDefinition
##' @export
add_ssffTrackDefinition <- function(emuDBhandle, name,
                                    columnName = NULL, fileExtension = NULL, 
                                    onTheFlyFunctionName = NULL, onTheFlyParams = NULL, 
                                    onTheFlyOptLogFilePath = NULL,
                                    verbose = TRUE, interactive = TRUE){
  
  dbConfig = load_DBconfig(emuDBhandle)
  
  #########################
  # parameter checks
  
  # set columnName to fist tracks entry in wrasspOutputInfos if columnName is not set
  if(!is.null(onTheFlyFunctionName) && is.null(columnName)){
    columnName = wrasspOutputInfos[[onTheFlyFunctionName]]$tracks[1]
  }
  
  # set fileExtension to fist ext entry in wrasspOutputInfos if fileExtension is not set
  if(!is.null(onTheFlyFunctionName) && is.null(fileExtension)){
    fileExtension = wrasspOutputInfos[[onTheFlyFunctionName]]$ext[1]
  }
  
  
  # check if three main parameters are not null
  if(is.null(name) || is.null(columnName) || is.null(fileExtension)){
    stop('name, columnName, fileExtension have to be set!')
  }
  
  # check if onTheFlyFunctionName is set if onTheFlyParams is
  if(is.null(onTheFlyFunctionName) && !is.null(onTheFlyParams)){
    stop('onTheFlyFunctionName has to be set if onTheFlyParams is set!')
  }
  
  # check if both onTheFlyFunctionName and onTheFlyParams are set if onTheFlyOptLogFilePath is 
  if( !is.null(onTheFlyOptLogFilePath) && (is.null(onTheFlyFunctionName) || is.null(onTheFlyParams))){
    stop('Both onTheFlyFunctionName and onTheFlyParams have to be set for you to be able to use the onTheFlyOptLogFilePath parameter!')
  }
  
  curDefs = list_ssffTrackDefinitions(emuDBhandle)
  
  if(sum(curDefs$name == name) != 0){
    stop("ssffTrackDefinitions with name ", name ," already exists for emuDB: ", emuDBhandle$dbName, "!")
  }
  
  ans = 'y'
  # calculate new files
  if(!is.null(onTheFlyFunctionName)){
    # check if files exist
    filesDf = list_files(emuDBhandle, fileExtension)
    if(nrow(filesDf) != 0){
      fp = paste(emuDBhandle$basePath, paste0(filesDf$session, session.suffix), paste0(filesDf$bundle, bundle.dir.suffix), filesDf$file, sep = .Platform$file.sep)
      if(interactive){
        ans = readline(paste0("There are files present in '",emuDBhandle$dbName,"' that have the file extention '", 
                              fileExtension, "'! Continuing will overwrite these files! Do you wish to proceed? (y/n) "))
      }
    }else{
      if(ans == 'y'){
        
        ###############################
        # set up function formals
        funcFormals = formals(onTheFlyFunctionName)
        funcFormals[names(onTheFlyParams)] = onTheFlyParams
        funcFormals$optLogFilePath = onTheFlyOptLogFilePath
        fp = list_files(emuDBhandle, dbConfig$mediafileExtension)
        funcFormals$listOfFiles = paste(emuDBhandle$basePath, paste0(fp$session, session.suffix), paste0(fp$bundle, bundle.dir.suffix), fp$file, sep = .Platform$file.sep)
        funcFormals$explicitExt = fileExtension
        funcFormals$verbose = verbose
        
        # check if columnName is valid track
        if(!(columnName %in% wrasspOutputInfos[[onTheFlyFunctionName]]$tracks)){
          stop("'", columnName ,"' is not a column produced by '", onTheFlyFunctionName, "'! Please check wrasspOutputInfos for information on the tracks of each wrassp function.")
        }
        
        do.call(onTheFlyFunctionName, funcFormals)
      }else{
        stop('Aborted by user...')
      }
    }
  }
  
  if(ans == 'y'){
    # add new ssffTrackDefinition
    dbConfig$ssffTrackDefinitions[[length(dbConfig$ssffTrackDefinitions) + 1]] = list(name = name, 
                                                                                      columnName = columnName,
                                                                                      fileExtension = fileExtension)
    # store changes
    store_DBconfig(emuDBhandle, dbConfig)
  }
}

##' @rdname ssffTrackDefinition
##' @export
list_ssffTrackDefinitions <- function(emuDBhandle){
  dbConfig = load_DBconfig(emuDBhandle)
  df <- do.call(rbind, lapply(dbConfig$ssffTrackDefinitions, data.frame, stringsAsFactors=FALSE))
  return(df)
}


##' @rdname ssffTrackDefinition
##' @export
remove_ssffTrackDefinition <- function(emuDBhandle, name, 
                                       deleteFiles = FALSE){
  
  dbConfig = load_DBconfig(emuDBhandle)
  
  # precheck if exists
  sDefs = list_ssffTrackDefinitions(emuDBhandle)  
  
  if(!(name %in% sDefs$name)){
    stop("No ssffTrackDefinitions found with name: '", name, "'")
  }
  # find end delete entry
  deletedDef = NULL
  for(i in 1:length(dbConfig$ssffTrackDefinitions)){
    if(dbConfig$ssffTrackDefinitions[[i]]$name == name){
      deletedDef = dbConfig$ssffTrackDefinitions[[i]]
      dbConfig$ssffTrackDefinitions[[i]] = NULL
      break
    }
  }
  
  # find and delete files
  if(deleteFiles){
    fp = list_files(emuDBhandle, deletedDef$fileExtension)
    fp = paste(emuDBhandle$basePath, paste0(fp$session, session.suffix), paste0(fp$bundle, bundle.dir.suffix), fp$file, sep = .Platform$file.sep)
    file.remove(fp)
  }
  # store changes
  store_DBconfig(emuDBhandle, dbConfig)
}